{"mappings":";;;;;;;;;;;AAGA,MAAM,kCAAY,CAAA,GAAA,qBAAQ,EAAE,CAAA,GAAA,yBAAG;AA6BxB,MAAM;IACX;;;;;;;yGAOuG,GACvG,OAAO,UAAU,GAAmB,EAAU;QAC5C,IAAI,QAAQ,WAAW,OAAO;QAC9B,IAAI,QAAQ,MAAM,OAAO;QAEzB,uBAAuB;QACvB,IAAI,CAAC,KAAK,OAAO;QAEjB,iDAAiD;QACjD,IAAI,uBAAuB,IAAI,CAAC,MAAM,OAAO;QAE7C,qEAAqE;QACrE,OAAO,CAAC,CAAC,EAAE,IAAI,OAAO,CAAC,MAAM,OAAO,CAAC,CAAC;IACxC;IAEA;;;;;;;;GAQC,GACD,aAAa,KAAK,OAAe,EAAE,OAAiB,EAAE,EAAE,IAAa,EAAE,UAA+B,CAAC,CAAC,EAAE,mBAAmB,EAAE,EAAE;QAC/H,MAAM,gBACJ,eAAe,cACf,SAAS,OACT,4CAA4C;QAC5C,0CAA0C;QAC1C,GAAG,aACJ,GAAG;QAEJ,+CAA+C;QAC/C,MAAM,cAAc,GAAG,QAAQ,CAAC,EAAE,KAAK,GAAG,CAAC,0CAAU,SAAS,EAAE,IAAI,CAAC,KAAK,CAAC,EAAE,kBAAkB;QAE/F,IAAI,CAAC,QACH,QAAQ,GAAG,CAAC,CAAC,WAAW,EAAE,OAAO,OAAO,GAAG,GAAG,EAAE,aAAa;QAG/D,IAAI;YACF,MAAM,UAAE,MAAM,UAAE,MAAM,EAAE,GAAG,MAAM,gCAAU,aAAa;YACxD,OAAO;gBACL,QAAQ,OAAO,IAAI;gBACnB,OAAO,OAAO,IAAI;sBAClB;YACF;QACF,EAAE,OAAO,OAAO;YACd,MAAM,IAAI,MAAM,CAAC,yBAAyB,EAAE,AAAC,MAAc,OAAO,EAAE;QACtE;IACF;IAEA;;;;;;;;GAQC,GACD,aAAa,MAAM,OAAe,EAAE,OAAiB,EAAE,EAAE,IAAa,EAAE,UAAgC,CAAC,CAAC,EAAsB;QAC9H,MAAM,gBACJ,eAAe,cACf,SAAS,OACT,4CAA4C;QAC5C,0CAA0C;QAC1C,GAAG,cACJ,GAAG;QAEJ,IAAI,CAAC,QACH,QAAQ,GAAG,CAAC,CAAC,WAAW,EAAE,OAAO,OAAO,GAAG,GAAG,EAAE,QAAQ,CAAC,EAAE,KAAK,IAAI,CAAC,MAAM;QAG7E,MAAM,YAAY,CAAA,GAAA,0BAAS,EAAE,SAAS,MAAM;YAC1C,OAAO;YACP,OAAO;YACP,GAAG,YAAY;QACjB;QAEA,MAAM,gBAA0B,EAAE;QAClC,MAAM,gBAA0B,EAAE;QAElC,UAAU,MAAM,EAAE,GAAG,QAAQ,CAAC;YAC5B,IAAI,CAAC,QACH,QAAQ,MAAM,CAAC,KAAK,CAAC;YAEvB,cAAc,IAAI,CAAC;QACrB;QAEA,UAAU,MAAM,EAAE,GAAG,QAAQ,CAAC;YAC5B,IAAI,CAAC,QACH,QAAQ,MAAM,CAAC,KAAK,CAAC;YAEvB,cAAc,IAAI,CAAC;QACrB;QAEA,OAAO,IAAI,QAAmB,CAAC,SAAS;YACtC,UAAU,EAAE,CAAC,SAAS,CAAC;gBACrB,MAAM,SAAS,OAAO,MAAM,CAAC,eAAe,QAAQ,GAAG,IAAI;gBAC3D,MAAM,QAAQ,OAAO,MAAM,CAAC,eAAe,QAAQ,GAAG,IAAI;gBAE1D,IAAI,SAAS,KAAK,cAAc;oBAC9B,MAAM,QAAQ,IAAI,MAAM,CAAC,8BAA8B,EAAE,MAAM;oBAC/D,OAAO,MAAM,CAAC,OAAO;wBAAE,QAAQ;wBAAQ,QAAQ;8BAAO;8BAAM;oBAAK;oBACjE,OAAO;gBACT,OACE,QAAQ;4BAAE;2BAAQ;0BAAO;0BAAM;gBAAK;YAExC;YAEA,UAAU,EAAE,CAAC,SAAS;QACxB;IACF;AACF","sources":["src/libs/CLIHelper.ts"],"sourcesContent":["import { exec, spawn as childSpawn, ExecOptions, SpawnOptions } from 'child_process'\r\nimport { promisify } from 'util'\r\n\r\nconst execAsync = promisify(exec)\r\n\r\nexport interface CLIResult {\r\n  output: string\r\n  error: string\r\n  code?: number\r\n  hint?: string\r\n}\r\n\r\nexport interface ExtendedSpawnOptions extends SpawnOptions {\r\n  /** Whether to throw an error on non-zero exit codes */\r\n  throwOnError?: boolean\r\n  /** Whether to log command execution */\r\n  silent?: boolean\r\n}\r\nexport interface ExtendedExecOptions extends ExecOptions {\r\n  /** Whether to throw an error on non-zero exit codes */\r\n  throwOnError?: boolean\r\n  /** Whether to log command execution */\r\n  silent?: boolean\r\n}\r\n\r\n/**\r\n * For most cases (simple commands where you know the input is safe), the simpler exec approach is sufficient.\r\n *\r\n * Use streaming with spawn only if dealing with very large outputs or needing real-time processing of the output as it comes in.\r\n * For complex command and incorporating user input into the command, there are security concerns with exec (proper escaping to prevent command injection).\r\n * In this case spawn is often preferred for more complex use cases - it handles argument passing more safely and explicitly.\r\n */\r\nexport class CLIHelper {\r\n  /** undefined will be \"\"\r\n   * Returns empty arguments as '\"\"'\r\nLeaves simple arguments without spaces/special chars unchanged\r\nFor complex arguments:\r\nEscapes any existing double quotes\r\nWraps the argument in double quotes\r\n\r\nIt's not as comprehensive as \"npm:shell-quote\" but handles most common cases safely and is much lighter. */\r\n  static escapeArg(arg?: string | null): string {\r\n    if (arg === undefined) return ''\r\n    if (arg === null) return ''\r\n\r\n    // Handle empty strings\r\n    if (!arg) return '\"\"'\r\n\r\n    // If argument has no special chars, return as is\r\n    if (/^[a-zA-Z0-9_\\/:=-]+$/.test(arg)) return arg\r\n\r\n    // Escape double quotes and wrap the entire argument in double quotes\r\n    return `\"${arg.replace(/\"/g, '\\\\\"')}\"`\r\n  }\r\n\r\n  /**\r\n   * Executes a shell command and returns its output (keep the output in memory and return all at once)\r\n   * @example await runCommand('echo', ['hello world', 'file name.txt'])\r\n   * @param command - The command to execute\r\n   * @param options - Node.js exec options (optional)\r\n   * @param hint - descriptive hint to know what command we're excuting (e.g.: we execute a complex and long ffmpeg command, put a hint here to describle it)\r\n   * @returns Promise resolving to process output details\r\n   * @throws Error if process fails\r\n   */\r\n  static async exec(command: string, args: string[] = [], hint?: string, options: ExtendedExecOptions = {}, bashCommandExtra = '') {\r\n    const {\r\n      throwOnError = true,\r\n      silent = false,\r\n      // uncomment to auto use process.env and cwd\r\n      // env = process.env, cwd = process.cwd(),\r\n      ...execOptions\r\n    } = options\r\n\r\n    // Properly escape all arguments (for security)\r\n    const fullCommand = `${command} ${args.map(CLIHelper.escapeArg).join(' ')} ${bashCommandExtra}`\r\n\r\n    if (!silent) {\r\n      console.log(`Executing (${hint ? hint : ''}): ${fullCommand}`)\r\n    }\r\n\r\n    try {\r\n      const { stdout, stderr } = await execAsync(fullCommand, options)\r\n      return {\r\n        output: stdout.trim(),\r\n        error: stderr.trim(),\r\n        hint\r\n      } as CLIResult\r\n    } catch (error) {\r\n      throw new Error(`Exec CLI command failed: ${(error as any).message}`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Spawns a child process and returns a promise that resolves with its output\r\n   * @param command - The command to execute\r\n   * @param args - Array of arguments to pass to the command\r\n   * @param options - Configuration options for process spawning\r\n   * @param hint - descriptive hint to know what command we're excuting (e.g.: we execute a complex and long ffmpeg command, put a hint here to describle it)\r\n   * @returns Promise resolving to process output details\r\n   * @throws Error if process fails\r\n   */\r\n  static async spawn(command: string, args: string[] = [], hint?: string, options: ExtendedSpawnOptions = {}): Promise<CLIResult> {\r\n    const {\r\n      throwOnError = true,\r\n      silent = false,\r\n      // uncomment to auto use process.env and cwd\r\n      // env = process.env, cwd = process.cwd(),\r\n      ...spawnOptions\r\n    } = options\r\n\r\n    if (!silent) {\r\n      console.log(`Executing (${hint ? hint : ''}): ${command} ${args.join(' ')}`)\r\n    }\r\n\r\n    const childProc = childSpawn(command, args, {\r\n      // env,\r\n      // cwd,\r\n      ...spawnOptions\r\n    })\r\n\r\n    const stdoutBuffers: Buffer[] = []\r\n    const stderrBuffers: Buffer[] = []\r\n\r\n    childProc.stdout?.on('data', (buffer: Buffer) => {\r\n      if (!silent) {\r\n        process.stdout.write(buffer)\r\n      }\r\n      stdoutBuffers.push(buffer)\r\n    })\r\n\r\n    childProc.stderr?.on('data', (buffer: Buffer) => {\r\n      if (!silent) {\r\n        process.stderr.write(buffer)\r\n      }\r\n      stderrBuffers.push(buffer)\r\n    })\r\n\r\n    return new Promise<CLIResult>((resolve, reject) => {\r\n      childProc.on('close', (code: number) => {\r\n        const output = Buffer.concat(stdoutBuffers).toString().trim()\r\n        const error = Buffer.concat(stderrBuffers).toString().trim()\r\n\r\n        if (code !== 0 && throwOnError) {\r\n          const error = new Error(`Process failed with exit code ${code}`)\r\n          Object.assign(error, { stdout: output, stderr: error, code, hint })\r\n          reject(error)\r\n        } else {\r\n          resolve({ output, error, code, hint } as CLIResult)\r\n        }\r\n      })\r\n\r\n      childProc.on('error', reject)\r\n    })\r\n  }\r\n}\r\n"],"names":[],"version":3,"file":"CLIHelper.15969611.js.map","sourceRoot":"../"}