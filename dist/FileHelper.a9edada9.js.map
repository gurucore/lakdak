{"mappings":"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","sources":["src/libs/FileHelper.ts"],"sourcesContent":["import os from 'os'\r\nimport path from 'path'\r\nimport { Readable } from 'stream'\r\nimport { promises as fsPromises, constants, createWriteStream } from 'fs'\r\n\r\nimport { DEBUG, UtilHelper } from './UtilHelper'\r\nimport { RawNetworkHelper } from './RawNetworkHelper'\r\n\r\nexport class FileHelper {\r\n  /** use promise based access() API to check existence */\r\n  static async checkFileExist(filePath?: string) {\r\n    if (!filePath) return false\r\n\r\n    try {\r\n      await fsPromises.access(filePath, constants.F_OK)\r\n      return true\r\n    } catch (err) {\r\n      if ((err as any).code === 'ENOENT') {\r\n        return false\r\n      } else {\r\n        throw err // Re-throw the error if it's not a \"file not found\" error\r\n      }\r\n    }\r\n  }\r\n\r\n  /** return the extension, include the dot (.) */\r\n  static getFileExtension(filePathOrURL?: string) {\r\n    if (!filePathOrURL) return ''\r\n    return path.extname(filePathOrURL)\r\n  }\r\n\r\n  /** copy files to OS temp dir  */\r\n  static async copyToTempDir(sourceFilePath: string) {\r\n    if (!sourceFilePath) return\r\n\r\n    const tmpFileName = path.basename(sourceFilePath)\r\n    const tmpFilePath = path.join(os.tmpdir(), tmpFileName)\r\n\r\n    try {\r\n      await fsPromises.copyFile(sourceFilePath, tmpFilePath)\r\n      DEBUG(`File copied: ${sourceFilePath} => ${tmpFilePath}`)\r\n      return tmpFilePath\r\n    } catch (err) {\r\n      console.error(`Error copying file: ${err}`)\r\n      throw err\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate a temp filePath in side temp dir (but it is just the file path, no file content existed)\r\n   * @param prefix prepend to the fileName\r\n   * @param fileExtension extension must be with the dot (.), append to the result fileName\r\n   * @returns\r\n   */\r\n  static generateNewTempFilePath(prefix: string = '', fileExtension = '') {\r\n    const tmpFileName = `${prefix}${UtilHelper.createRandom()}${fileExtension}`\r\n    const tmpFilePath = path.join(os.tmpdir(), tmpFileName)\r\n\r\n    return tmpFilePath\r\n  }\r\n\r\n  /** try to delete files */\r\n  static async unlinksSafe(paths: string[]) {\r\n    const arr = paths.map(async (p) => {\r\n      if (await FileHelper.checkFileExist(p)) {\r\n        await fsPromises.unlink(p)\r\n      }\r\n    })\r\n\r\n    return Promise.all(arr)\r\n  }\r\n\r\n  /**\r\n   * download remote file into local temp dir\r\n   * @param link\r\n   * @returns local temp file path\r\n   */\r\n  static async cacheRemoteUrl(link: string) {\r\n    if (!link) throw new Error(`argument link:${link} is empty, neither URL nor localFile`)\r\n\r\n    if (UtilHelper.isLocalFilePath(link)) {\r\n      return link // already in local, no need to download\r\n    }\r\n\r\n    if (!UtilHelper.isURL(link)) {\r\n      throw new Error(`argument link:${link} is neither URL nor localFile`)\r\n    }\r\n\r\n    const url = link\r\n    // https://vbee-studio-tmp.s3.ap-southeast-1.amazonaws.com/voice-cloning/voices/6765858815ba1ce0979a8b35/filename.wav ==> filename.wav\r\n    const fileName = path.basename(link) // = link.split('/').slice(-1)[0]\r\n    const outputFilePath = FileHelper.generateNewTempFilePath('temp-cached_', '_' + fileName)\r\n\r\n    try {\r\n      await RawNetworkHelper.download(url, outputFilePath)\r\n    } catch (err) {\r\n      console.error('Error: 404 not Found: ', url, (err as any).code)\r\n    }\r\n\r\n    return outputFilePath\r\n  }\r\n\r\n  /**\r\n   * write content to file\r\n   * @param content\r\n   * @param filePath\r\n   * @returns written filePath, or undefined if error\r\n   */\r\n  static async writeDataToFile(content: string | Buffer, filePath: string) {\r\n    if (!filePath) return\r\n    if (!content) return\r\n\r\n    try {\r\n      await fsPromises.writeFile(filePath, content)\r\n      return filePath\r\n    } catch (err) {\r\n      console.error(`Failed to save content to file ${filePath}`, { filePath, error: err })\r\n    }\r\n  }\r\n\r\n  /**\r\n   * pipe stream to file\r\n   * @param readableStream\r\n   * @param filePath\r\n   * @returns written filePath, throw if error\r\n   */\r\n  static async writeStreamToFile(readableStream: Readable, filePath: string) {\r\n    if (!filePath) return\r\n    if (!readableStream) return\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const writableStream = createWriteStream(filePath)\r\n\r\n      readableStream.on('error', (err) => {\r\n        reject(err)\r\n      })\r\n      writableStream.on('error', (err) => {\r\n        reject(err)\r\n      })\r\n      writableStream.on('finish', () => {\r\n        resolve(filePath)\r\n      })\r\n\r\n      readableStream.pipe(writableStream)\r\n    })\r\n  }\r\n}\r\n"],"names":[],"version":3,"file":"FileHelper.a9edada9.js.map","sourceRoot":"../"}