{"mappings":";;;;;;;;;;;;;;;;;;;;;AAOO,MAAM;IACX,sDAAsD,GACtD,aAAa,eAAe,QAAiB,EAAE;QAC7C,IAAI,CAAC,UAAU,OAAO;QAEtB,IAAI;YACF,MAAM,CAAA,GAAA,kBAAS,EAAE,MAAM,CAAC,UAAU,CAAA,GAAA,mBAAQ,EAAE,IAAI;YAChD,OAAO;QACT,EAAE,OAAO,KAAK;YACZ,IAAI,AAAC,IAAY,IAAI,KAAK,UACxB,OAAO;iBAEP,MAAM,IAAI,0DAA0D;;QAExE;IACF;IAEA,8CAA8C,GAC9C,OAAO,iBAAiB,aAAsB,EAAE;QAC9C,IAAI,CAAC,eAAe,OAAO;QAC3B,OAAO,CAAA,GAAA,qCAAG,EAAE,OAAO,CAAC;IACtB;IAEA,+BAA+B,GAC/B,aAAa,cAAc,cAAsB,EAAE;QACjD,IAAI,CAAC,gBAAgB;QAErB,MAAM,cAAc,CAAA,GAAA,qCAAG,EAAE,QAAQ,CAAC;QAClC,MAAM,cAAc,CAAA,GAAA,qCAAG,EAAE,IAAI,CAAC,CAAA,GAAA,mCAAC,EAAE,MAAM,IAAI;QAE3C,IAAI;YACF,MAAM,CAAA,GAAA,kBAAS,EAAE,QAAQ,CAAC,gBAAgB;YAC1C,CAAA,GAAA,+BAAI,EAAE,CAAC,aAAa,EAAE,eAAe,IAAI,EAAE,aAAa;YACxD,OAAO;QACT,EAAE,OAAO,KAAK;YACZ,QAAQ,KAAK,CAAC,CAAC,oBAAoB,EAAE,KAAK;YAC1C,MAAM;QACR;IACF;IAEA;;;;;GAKC,GACD,OAAO,wBAAwB,SAAiB,EAAE,EAAE,gBAAgB,EAAE,EAAE;QACtE,MAAM,cAAc,GAAG,SAAS,CAAA,GAAA,oCAAS,EAAE,YAAY,KAAK,eAAe;QAC3E,MAAM,cAAc,CAAA,GAAA,qCAAG,EAAE,IAAI,CAAC,CAAA,GAAA,mCAAC,EAAE,MAAM,IAAI;QAE3C,OAAO;IACT;IAEA,wBAAwB,GACxB,aAAa,YAAY,KAAe,EAAE;QACxC,MAAM,MAAM,MAAM,GAAG,CAAC,OAAO;YAC3B,IAAI,MAAM,0CAAW,cAAc,CAAC,IAClC,MAAM,CAAA,GAAA,kBAAS,EAAE,MAAM,CAAC;QAE5B;QAEA,OAAO,QAAQ,GAAG,CAAC;IACrB;IAEA;;;;GAIC,GACD,aAAa,eAAe,IAAY,EAAE;QACxC,IAAI,CAAC,MAAM,MAAM,IAAI,MAAM,CAAC,cAAc,EAAE,KAAK,oCAAoC,CAAC;QAEtF,IAAI,CAAA,GAAA,oCAAS,EAAE,eAAe,CAAC,OAC7B,OAAO,KAAK,wCAAwC;;QAGtD,IAAI,CAAC,CAAA,GAAA,oCAAS,EAAE,KAAK,CAAC,OACpB,MAAM,IAAI,MAAM,CAAC,cAAc,EAAE,KAAK,6BAA6B,CAAC;QAGtE,MAAM,MAAM;QACZ,sIAAsI;QACtI,MAAM,WAAW,CAAA,GAAA,qCAAG,EAAE,QAAQ,CAAC,MAAM,iCAAiC;;QACtE,MAAM,iBAAiB,0CAAW,uBAAuB,CAAC,gBAAgB,MAAM;QAEhF,IAAI;YACF,MAAM,CAAA,GAAA,0CAAe,EAAE,QAAQ,CAAC,KAAK;QACvC,EAAE,OAAO,KAAK;YACZ,QAAQ,KAAK,CAAC,0BAA0B,KAAK,AAAC,IAAY,IAAI;QAChE;QAEA,OAAO;IACT;AACF","sources":["src/libs/FileHelper.ts"],"sourcesContent":["import os from 'os'\r\nimport path from 'path'\r\nimport { promises as fsPromises, constants } from 'fs'\r\n\r\nimport { DEBUG, UtilHelper } from './UtilHelper'\r\nimport { RawNetworkHelper } from './RawNetworkHelper'\r\n\r\nexport class FileHelper {\r\n  /** use promise based access() API to check existence */\r\n  static async checkFileExist(filePath?: string) {\r\n    if (!filePath) return false\r\n\r\n    try {\r\n      await fsPromises.access(filePath, constants.F_OK)\r\n      return true\r\n    } catch (err) {\r\n      if ((err as any).code === 'ENOENT') {\r\n        return false\r\n      } else {\r\n        throw err // Re-throw the error if it's not a \"file not found\" error\r\n      }\r\n    }\r\n  }\r\n\r\n  /** return the extension, include the dot (.) */\r\n  static getFileExtension(filePathOrURL?: string) {\r\n    if (!filePathOrURL) return ''\r\n    return path.extname(filePathOrURL)\r\n  }\r\n\r\n  /** copy files to OS temp dir  */\r\n  static async copyToTempDir(sourceFilePath: string) {\r\n    if (!sourceFilePath) return\r\n\r\n    const tmpFileName = path.basename(sourceFilePath)\r\n    const tmpFilePath = path.join(os.tmpdir(), tmpFileName)\r\n\r\n    try {\r\n      await fsPromises.copyFile(sourceFilePath, tmpFilePath)\r\n      DEBUG(`File copied: ${sourceFilePath} => ${tmpFilePath}`)\r\n      return tmpFilePath\r\n    } catch (err) {\r\n      console.error(`Error copying file: ${err}`)\r\n      throw err\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate a temp filePath in side temp dir (but it is just the file path, no file content existed)\r\n   * @param prefix prepend to the fileName\r\n   * @param fileExtension extension must be with the dot (.), append to the result fileName\r\n   * @returns\r\n   */\r\n  static generateNewTempFilePath(prefix: string = '', fileExtension = '') {\r\n    const tmpFileName = `${prefix}${UtilHelper.createRandom()}${fileExtension}`\r\n    const tmpFilePath = path.join(os.tmpdir(), tmpFileName)\r\n\r\n    return tmpFilePath\r\n  }\r\n\r\n  /** try to delete files */\r\n  static async unlinksSafe(paths: string[]) {\r\n    const arr = paths.map(async (p) => {\r\n      if (await FileHelper.checkFileExist(p)) {\r\n        await fsPromises.unlink(p)\r\n      }\r\n    })\r\n\r\n    return Promise.all(arr)\r\n  }\r\n\r\n  /**\r\n   * download remote file into local temp dir\r\n   * @param link\r\n   * @returns local temp file path\r\n   */\r\n  static async cacheRemoteUrl(link: string) {\r\n    if (!link) throw new Error(`argument link:${link} is empty, neither URL nor localFile`)\r\n\r\n    if (UtilHelper.isLocalFilePath(link)) {\r\n      return link // already in local, no need to download\r\n    }\r\n\r\n    if (!UtilHelper.isURL(link)) {\r\n      throw new Error(`argument link:${link} is neither URL nor localFile`)\r\n    }\r\n\r\n    const url = link\r\n    // https://vbee-studio-tmp.s3.ap-southeast-1.amazonaws.com/voice-cloning/voices/6765858815ba1ce0979a8b35/filename.wav ==> filename.wav\r\n    const fileName = path.basename(link) // = link.split('/').slice(-1)[0]\r\n    const outputFilePath = FileHelper.generateNewTempFilePath('temp-cached_', '_' + fileName)\r\n\r\n    try {\r\n      await RawNetworkHelper.download(url, outputFilePath)\r\n    } catch (err) {\r\n      console.error('Error: 404 not Found: ', url, (err as any).code)\r\n    }\r\n\r\n    return outputFilePath\r\n  }\r\n}\r\n"],"names":[],"version":3,"file":"FileHelper.0d84a89a.js.map","sourceRoot":"../"}