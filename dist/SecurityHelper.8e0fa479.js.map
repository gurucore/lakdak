{"mappings":";;AAAA,8BAA8B;;AAIf;IACb;;;;;GAKC,GACD,OAAO,KAAK,KAAwB,EAAE,YAAY,QAAQ,EAAU;QAClE,IAAI,CAAC,OAAO;QAEZ,OAAO,CAAA,GAAA,aAAK,EAAE,UAAU,CAAC,WAAW,MAAM,CAAC,OAAO,MAAM,CAAC;IAC3D;IAEA;;;;GAIC,GACD,OAAO,mBAAmB,gBAAgB,IAAI,EAA+D;QAC3G,MAAM,aAAE,SAAS,cAAE,UAAU,EAAE,GAAG,CAAA,GAAA,aAAK,EAAE,mBAAmB,CAAC,OAAO;2BAClE;YACA,mBAAmB;gBACjB,MAAM;gBACN,QAAQ;YACV;YACA,oBAAoB;gBAClB,MAAM;gBACN,QAAQ;YACV;QACF;QACA,OAAO;uBAAE;wBAAW;QAAW;IACjC;IAEA;;;;;;GAMC,GACD,OAAO,YAAY,SAAS,EAAE,SAAiB,EAAU;QACvD,MAAM,gBAAgB,CAAA,GAAA,aAAK,EAAE,aAAa,CACxC;YACE,KAAK;YACL,SAAS,CAAA,GAAA,aAAK,EAAE,SAAS,CAAC,sBAAsB;YAChD,UAAU;QACZ,GACA,OAAO,IAAI,CAAC;QAEd,OAAO,cAAc,QAAQ,CAAC;IAChC;IAEA;;;;;;GAMC,GACD,OAAO,YAAY,UAAU,EAAE,mBAA2B,EAAU;QAClE,MAAM,gBAAgB,CAAA,GAAA,aAAK,EAAE,cAAc,CACzC;YACE,KAAK;YACL,uDAAuD;YACvD,2DAA2D;YAC3D,wCAAwC;YACxC,SAAS,CAAA,GAAA,aAAK,EAAE,SAAS,CAAC,sBAAsB;YAChD,UAAU;QACZ,GACA,OAAO,IAAI,CAAC,qBAAqB;QAEnC,OAAO,cAAc,QAAQ,CAAC;IAChC;AACF","sources":["src/libs/SecurityHelper.ts"],"sourcesContent":["/// <reference types=\"node\" />\n\nimport crypto from 'crypto'\n\nexport default class SecurityHelper {\n  /**\n   *\n   * @param input\n   * @param algorithm  \"sha1\" \"sha256\"\n   * @returns hex string\n   */\n  static hash(input: crypto.BinaryLike, algorithm = 'sha256'): string {\n    if (!input) return\n\n    return crypto.createHash(algorithm).update(input).digest('hex')\n  }\n\n  /**\n   *\n   * @param modulusLength effective key size 2048 bit (good until 2030), after 2030, use 3072 bit\n   * @returns keypair: object of public and private\n   */\n  static generateRSAKeyPair(modulusLength = 2048): { publicKey: string | Buffer; privateKey: string | Buffer } {\n    const { publicKey, privateKey } = crypto.generateKeyPairSync('rsa', {\n      modulusLength,\n      publicKeyEncoding: {\n        type: 'spki',\n        format: 'pem'\n      },\n      privateKeyEncoding: {\n        type: 'pkcs8',\n        format: 'pem'\n      }\n    })\n    return { publicKey, privateKey }\n  }\n\n  /**\n   * Encrypt using publicKey, the encrypted data is in the form of bytes, so we print it in base64 format\n   * so that it's displayed in a more readable form\n   * @param publicKey\n   * @param plainText\n   * @returns String base64 format\n   */\n  static encryptText(publicKey, plainText: string): string {\n    const encryptedData = crypto.publicEncrypt(\n      {\n        key: publicKey,\n        padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,\n        oaepHash: 'sha256'\n      },\n      Buffer.from(plainText)\n    )\n    return encryptedData.toString('base64')\n  }\n\n  /**\n   * decrypt using privateKey. The decrypted data is of the Buffer type,\n   * which we can convert to a string to reveal the original data\n   * @param privateKey\n   * @param encryptedTextBase64 String in base64 format\n   * @returns utf-8 string\n   */\n  static decryptText(privateKey, encryptedTextBase64: string): string {\n    const decryptedData = crypto.privateDecrypt(\n      {\n        key: privateKey,\n        // In order to decrypt the data, we need to specify the\n        // same hashing function and padding scheme that we used to\n        // encrypt the data in the previous step\n        padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,\n        oaepHash: 'sha256'\n      },\n      Buffer.from(encryptedTextBase64, 'base64')\n    )\n    return decryptedData.toString('utf8')\n  }\n}\n"],"names":[],"version":3,"file":"SecurityHelper.8e0fa479.js.map","sourceRoot":"../"}