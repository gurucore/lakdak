{"mappings":";;AAAA,8BAA8B;;AAIf;IACb;;;;;GAKC,GACD,OAAO,KAAK,KAAwB,EAAE,YAAY,QAAQ,EAAU;QAClE,IAAI,CAAC,OAAO;QAEZ,OAAO,CAAA,GAAA,aAAK,EAAE,UAAU,CAAC,WAAW,MAAM,CAAC,OAAO,MAAM,CAAC;IAC3D;IAEA;;;;GAIC,GACD,OAAO,mBAAmB,gBAAgB,IAAI,EAA+D;QAC3G,MAAM,aAAE,SAAS,cAAE,UAAU,EAAE,GAAG,CAAA,GAAA,aAAK,EAAE,mBAAmB,CAAC,OAAO;2BAClE;YACA,mBAAmB;gBACjB,MAAM;gBACN,QAAQ;YACV;YACA,oBAAoB;gBAClB,MAAM;gBACN,QAAQ;YACV;QACF;QACA,OAAO;uBAAE;wBAAW;QAAW;IACjC;IAEA;;;;;;GAMC,GACD,OAAO,YAAY,SAAS,EAAE,SAAiB,EAAU;QACvD,MAAM,gBAAgB,CAAA,GAAA,aAAK,EAAE,aAAa,CACxC;YACE,KAAK;YACL,SAAS,CAAA,GAAA,aAAK,EAAE,SAAS,CAAC,sBAAsB;YAChD,UAAU;QACZ,GACA,OAAO,IAAI,CAAC;QAEd,OAAO,cAAc,QAAQ,CAAC;IAChC;IAEA;;;;;;GAMC,GACD,OAAO,YAAY,UAAU,EAAE,mBAA2B,EAAU;QAClE,MAAM,gBAAgB,CAAA,GAAA,aAAK,EAAE,cAAc,CACzC;YACE,KAAK;YACL,uDAAuD;YACvD,2DAA2D;YAC3D,wCAAwC;YACxC,SAAS,CAAA,GAAA,aAAK,EAAE,SAAS,CAAC,sBAAsB;YAChD,UAAU;QACZ,GACA,OAAO,IAAI,CAAC,qBAAqB;QAEnC,OAAO,cAAc,QAAQ,CAAC;IAChC;AACF","sources":["src/libs/SecurityHelper.ts"],"sourcesContent":["/// <reference types=\"node\" />\r\n\r\nimport crypto from 'crypto'\r\n\r\nexport default class SecurityHelper {\r\n  /**\r\n   *\r\n   * @param input\r\n   * @param algorithm  \"sha1\" \"sha256\"\r\n   * @returns hex string\r\n   */\r\n  static hash(input: crypto.BinaryLike, algorithm = 'sha256'): string {\r\n    if (!input) return\r\n\r\n    return crypto.createHash(algorithm).update(input).digest('hex')\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param modulusLength effective key size 2048 bit (good until 2030), after 2030, use 3072 bit\r\n   * @returns keypair: object of public and private\r\n   */\r\n  static generateRSAKeyPair(modulusLength = 2048): { publicKey: string | Buffer; privateKey: string | Buffer } {\r\n    const { publicKey, privateKey } = crypto.generateKeyPairSync('rsa', {\r\n      modulusLength,\r\n      publicKeyEncoding: {\r\n        type: 'spki',\r\n        format: 'pem'\r\n      },\r\n      privateKeyEncoding: {\r\n        type: 'pkcs8',\r\n        format: 'pem'\r\n      }\r\n    })\r\n    return { publicKey, privateKey }\r\n  }\r\n\r\n  /**\r\n   * Encrypt using publicKey, the encrypted data is in the form of bytes, so we print it in base64 format\r\n   * so that it's displayed in a more readable form\r\n   * @param publicKey\r\n   * @param plainText\r\n   * @returns String base64 format\r\n   */\r\n  static encryptText(publicKey, plainText: string): string {\r\n    const encryptedData = crypto.publicEncrypt(\r\n      {\r\n        key: publicKey,\r\n        padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,\r\n        oaepHash: 'sha256'\r\n      },\r\n      Buffer.from(plainText)\r\n    )\r\n    return encryptedData.toString('base64')\r\n  }\r\n\r\n  /**\r\n   * decrypt using privateKey. The decrypted data is of the Buffer type,\r\n   * which we can convert to a string to reveal the original data\r\n   * @param privateKey\r\n   * @param encryptedTextBase64 String in base64 format\r\n   * @returns utf-8 string\r\n   */\r\n  static decryptText(privateKey, encryptedTextBase64: string): string {\r\n    const decryptedData = crypto.privateDecrypt(\r\n      {\r\n        key: privateKey,\r\n        // In order to decrypt the data, we need to specify the\r\n        // same hashing function and padding scheme that we used to\r\n        // encrypt the data in the previous step\r\n        padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,\r\n        oaepHash: 'sha256'\r\n      },\r\n      Buffer.from(encryptedTextBase64, 'base64')\r\n    )\r\n    return decryptedData.toString('utf8')\r\n  }\r\n}\r\n"],"names":[],"version":3,"file":"SecurityHelper.77a5b20e.js.map","sourceRoot":"../"}