{"mappings":"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","sources":["src/index.ts","src/libs/DevOpsHelper.ts","src/libs/SecurityHelper.ts","src/libs/HttpProtocolHelper.ts","src/libs/CLIHelper.ts","src/libs/FileHelper.ts","src/libs/UtilHelper.ts","src/libs/NetworkHelper.ts","src/models/CustomError.ts"],"sourcesContent":["import DevOpsHelper from './libs/DevOpsHelper'\nimport SecurityHelper from './libs/SecurityHelper'\nimport HttpProtocolHelper from './libs/HttpProtocolHelper'\nimport { CLIHelper } from './libs/CLIHelper'\nimport { FileHelper } from './libs/FileHelper'\nimport { RawNetworkHelper } from './libs/NetworkHelper'\nimport { UtilHelper } from './libs/UtilHelper'\n\nexport {\n  DevOpsHelper,\n  SecurityHelper,\n  HttpProtocolHelper,\n\n  //\n  CLIHelper,\n  FileHelper,\n  RawNetworkHelper,\n  UtilHelper\n}\n","/// <reference types=\"node\" />\n\nimport os from 'os'\n\n/**\n * Helper to inspect, check, analyse command send to chatbot\n */\nexport default class DevOpsHelper {\n  /**\n   * Get current server IP address\n   * @param ipType \"v4\" or \"v6\"\n   * @returns\n   */\n  static getCurrentServerIpAddresses(ipType = 'v4'): string {\n    const networkInterfaces = Object.values(os.networkInterfaces())\n      .reduce((r, a) => {\n        r = r.concat(a)\n        return r\n      }, [])\n      .filter(({ family, address }) => {\n        return family.toLowerCase().indexOf(ipType) >= 0 && address !== '127.0.0.1'\n      })\n      .map(({ address }) => address)\n    const serverIpAddresses = networkInterfaces.join(', ')\n    return serverIpAddresses\n  }\n\n  /**\n   * Get IP from request (if behind proxy, use X-Forwarded-For header)\n   * @param req\n   * @returns\n   */\n  public static extractIpFromRequest(req) {\n    // TODO: should improve this func to whitelist the proxies\n    // TODO: should use this library https://www.npmjs.com/package/request-ip\n    return req?.socket?.remoteAddress || req?.headers['x-forwarded-for']\n  }\n}\n","/// <reference types=\"node\" />\n\nimport crypto from 'crypto'\n\nexport default class SecurityHelper {\n  /**\n   *\n   * @param input\n   * @param algorithm  \"sha1\" \"sha256\"\n   * @returns hex string\n   */\n  static hash(input: crypto.BinaryLike, algorithm = 'sha256'): string {\n    if (!input) return\n\n    return crypto.createHash(algorithm).update(input).digest('hex')\n  }\n\n  /**\n   *\n   * @param modulusLength effective key size 2048 bit (good until 2030), after 2030, use 3072 bit\n   * @returns keypair: object of public and private\n   */\n  static generateRSAKeyPair(modulusLength = 2048): { publicKey: string | Buffer; privateKey: string | Buffer } {\n    const { publicKey, privateKey } = crypto.generateKeyPairSync('rsa', {\n      modulusLength,\n      publicKeyEncoding: {\n        type: 'spki',\n        format: 'pem'\n      },\n      privateKeyEncoding: {\n        type: 'pkcs8',\n        format: 'pem'\n      }\n    })\n    return { publicKey, privateKey }\n  }\n\n  /**\n   * Encrypt using publicKey, the encrypted data is in the form of bytes, so we print it in base64 format\n   * so that it's displayed in a more readable form\n   * @param publicKey\n   * @param plainText\n   * @returns String base64 format\n   */\n  static encryptText(publicKey, plainText: string): string {\n    const encryptedData = crypto.publicEncrypt(\n      {\n        key: publicKey,\n        padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,\n        oaepHash: 'sha256'\n      },\n      Buffer.from(plainText)\n    )\n    return encryptedData.toString('base64')\n  }\n\n  /**\n   * decrypt using privateKey. The decrypted data is of the Buffer type,\n   * which we can convert to a string to reveal the original data\n   * @param privateKey\n   * @param encryptedTextBase64 String in base64 format\n   * @returns utf-8 string\n   */\n  static decryptText(privateKey, encryptedTextBase64: string): string {\n    const decryptedData = crypto.privateDecrypt(\n      {\n        key: privateKey,\n        // In order to decrypt the data, we need to specify the\n        // same hashing function and padding scheme that we used to\n        // encrypt the data in the previous step\n        padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,\n        oaepHash: 'sha256'\n      },\n      Buffer.from(encryptedTextBase64, 'base64')\n    )\n    return decryptedData.toString('utf8')\n  }\n}\n","/** Helper to work with HTTP Protocol */\nexport default class HttpProtocolHelper {\n  /**\n   * extract bearer token from request header\n   * @param req\n   * @returns\n   */\n  public static extractBearerToken(req) {\n    const hash = req?.headers?.authorization?.replace(\"Bearer \", \"\")\n\n    return hash\n  }\n}\n","import { exec, spawn as childSpawn, ExecOptions, SpawnOptions } from 'child_process'\r\nimport { promisify } from 'util'\r\n\r\nconst execAsync = promisify(exec)\r\n\r\ninterface CLIResult {\r\n  output: string\r\n  error: string\r\n  code?: number\r\n  hint?: string\r\n}\r\n\r\ninterface ExtendedSpawnOptions extends SpawnOptions {\r\n  /** Whether to throw an error on non-zero exit codes */\r\n  throwOnError?: boolean\r\n  /** Whether to log command execution */\r\n  silent?: boolean\r\n}\r\ninterface ExtendedExecOptions extends ExecOptions {\r\n  /** Whether to throw an error on non-zero exit codes */\r\n  throwOnError?: boolean\r\n  /** Whether to log command execution */\r\n  silent?: boolean\r\n}\r\n\r\n/**\r\n * For most cases (simple commands where you know the input is safe), the simpler exec approach is sufficient.\r\n *\r\n * Use streaming with spawn only if dealing with very large outputs or needing real-time processing of the output as it comes in.\r\n * For complex command and incorporating user input into the command, there are security concerns with exec (proper escaping to prevent command injection).\r\n * In this case spawn is often preferred for more complex use cases - it handles argument passing more safely and explicitly.\r\n */\r\nexport class CLIHelper {\r\n  /** undefined will be \"\"\r\n   * Returns empty arguments as '\"\"'\r\nLeaves simple arguments without spaces/special chars unchanged\r\nFor complex arguments:\r\nEscapes any existing double quotes\r\nWraps the argument in double quotes\r\n\r\nIt's not as comprehensive as \"npm:shell-quote\" but handles most common cases safely and is much lighter. */\r\n  static escapeArg(arg?: string | null): string {\r\n    if (arg === undefined) return ''\r\n    if (arg === null) return ''\r\n\r\n    // Handle empty strings\r\n    if (!arg) return '\"\"'\r\n\r\n    // If argument has no special chars, return as is\r\n    if (/^[a-zA-Z0-9_\\/:=-]+$/.test(arg)) return arg\r\n\r\n    // Escape double quotes and wrap the entire argument in double quotes\r\n    return `\"${arg.replace(/\"/g, '\\\\\"')}\"`\r\n  }\r\n\r\n  /**\r\n   * Executes a shell command and returns its output (keep the output in memory and return all at once)\r\n   * @example await runCommand('echo', ['hello world', 'file name.txt'])\r\n   * @param command - The command to execute\r\n   * @param options - Node.js exec options (optional)\r\n   * @param hint - descriptive hint to know what command we're excuting (e.g.: we execute a complex and long ffmpeg command, put a hint here to describle it)\r\n   * @returns Promise resolving to process output details\r\n   * @throws Error if process fails\r\n   */\r\n  static async exec(command: string, args: string[] = [], hint?: string, options: ExtendedExecOptions = {}, bashCommandExtra = '') {\r\n    const {\r\n      throwOnError = true,\r\n      silent = false,\r\n      // uncomment to auto use process.env and cwd\r\n      // env = process.env, cwd = process.cwd(),\r\n      ...execOptions\r\n    } = options\r\n\r\n    // Properly escape all arguments (for security)\r\n    const fullCommand = `${command} ${args.map(CLIHelper.escapeArg).join(' ')} ${bashCommandExtra}`\r\n\r\n    if (!silent) {\r\n      console.log(`Executing (${hint ? hint : ''}): ${fullCommand}`)\r\n    }\r\n\r\n    try {\r\n      const { stdout, stderr } = await execAsync(fullCommand, options)\r\n      return {\r\n        output: stdout.trim(),\r\n        error: stderr.trim(),\r\n        hint,\r\n      } as CLIResult\r\n    } catch (error) {\r\n      throw new Error(`Exec CLI command failed: ${(error as any).message}`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Spawns a child process and returns a promise that resolves with its output\r\n   * @param command - The command to execute\r\n   * @param args - Array of arguments to pass to the command\r\n   * @param options - Configuration options for process spawning\r\n   * @param hint - descriptive hint to know what command we're excuting (e.g.: we execute a complex and long ffmpeg command, put a hint here to describle it)\r\n   * @returns Promise resolving to process output details\r\n   * @throws Error if process fails\r\n   */\r\n  static async spawn(command: string, args: string[] = [], hint?: string, options: ExtendedSpawnOptions = {}): Promise<CLIResult> {\r\n    const {\r\n      throwOnError = true,\r\n      silent = false,\r\n      // uncomment to auto use process.env and cwd\r\n      // env = process.env, cwd = process.cwd(),\r\n      ...spawnOptions\r\n    } = options\r\n\r\n    if (!silent) {\r\n      console.log(`Executing (${hint ? hint : ''}): ${command} ${args.join(' ')}`)\r\n    }\r\n\r\n    const childProc = childSpawn(command, args, {\r\n      // env,\r\n      // cwd,\r\n      ...spawnOptions,\r\n    })\r\n\r\n    const stdoutBuffers: Buffer[] = []\r\n    const stderrBuffers: Buffer[] = []\r\n\r\n    childProc.stdout?.on('data', (buffer: Buffer) => {\r\n      if (!silent) {\r\n        process.stdout.write(buffer)\r\n      }\r\n      stdoutBuffers.push(buffer)\r\n    })\r\n\r\n    childProc.stderr?.on('data', (buffer: Buffer) => {\r\n      if (!silent) {\r\n        process.stderr.write(buffer)\r\n      }\r\n      stderrBuffers.push(buffer)\r\n    })\r\n\r\n    return new Promise<CLIResult>((resolve, reject) => {\r\n      childProc.on('close', (code: number) => {\r\n        const output = Buffer.concat(stdoutBuffers).toString().trim()\r\n        const error = Buffer.concat(stderrBuffers).toString().trim()\r\n\r\n        if (code !== 0 && throwOnError) {\r\n          const error = new Error(`Process failed with exit code ${code}`)\r\n          Object.assign(error, { stdout: output, stderr: error, code, hint })\r\n          reject(error)\r\n        } else {\r\n          resolve({ output, error, code, hint } as CLIResult)\r\n        }\r\n      })\r\n\r\n      childProc.on('error', reject)\r\n    })\r\n  }\r\n\r\n  /**\r\n   * @deprecated This method is kept for backward compatible if there is a problem with new implementation.\r\n   */\r\n  static async spawnOld(command: string, args: string[] = [], options: SpawnOptions = {}) {\r\n    console.log(`Executing: ${command} ${args.join(' ')}`)\r\n\r\n    const childProc = childSpawn(command, args, {\r\n      env: options.env || process.env,\r\n      cwd: options.cwd || process.cwd(),\r\n      ...options,\r\n    })\r\n\r\n    const resultBuffers: Buffer[] = []\r\n\r\n    childProc.stdout.on('data', (buffer: Buffer) => {\r\n      console.log(buffer.toString())\r\n      resultBuffers.push(buffer)\r\n    })\r\n\r\n    childProc.stderr.on('data', (buffer: Buffer) => {\r\n      console.error(buffer.toString())\r\n    })\r\n\r\n    return new Promise((resolve, reject) => {\r\n      childProc.on('close', (code: number) => {\r\n        if (code === 0) {\r\n          resolve(Buffer.concat(resultBuffers).toString().trim())\r\n        } else {\r\n          reject(new Error(`${command} failed with exit code ${code}`))\r\n        }\r\n      })\r\n\r\n      childProc.on('error', (err: Error) => {\r\n        reject(err)\r\n      })\r\n    })\r\n  }\r\n}\r\n","import os from 'os'\r\nimport path from 'path'\r\n\r\nimport { promises as fsPromises, constants } from 'fs'\r\n\r\nimport { CLIHelper } from './CLIHelper'\r\nimport { DEBUG, UtilHelper } from './UtilHelper'\r\nimport { RawNetworkHelper } from './NetworkHelper'\r\n\r\nexport class FileHelper {\r\n  static async checkFileExist(filePath?: string) {\r\n    if (!filePath) return false\r\n\r\n    try {\r\n      await fsPromises.access(filePath, constants.F_OK)\r\n      return true\r\n    } catch (err) {\r\n      if ((err as any).code === 'ENOENT') {\r\n        return false\r\n      } else {\r\n        throw err // Re-throw the error if it's not a \"file not found\" error\r\n      }\r\n    }\r\n  }\r\n\r\n  /** return the extension, include the dot (.) */\r\n  static getFileExtension(filePathOrURL?: string) {\r\n    if (!filePathOrURL) return ''\r\n    return path.extname(filePathOrURL)\r\n  }\r\n\r\n  /** copy files to OS temp dir  */\r\n  static async copyToTempDir(sourceFilePath: string) {\r\n    if (!sourceFilePath) return\r\n\r\n    const tmpFileName = path.basename(sourceFilePath)\r\n    const tmpFilePath = path.join(os.tmpdir(), tmpFileName)\r\n\r\n    try {\r\n      await fsPromises.copyFile(sourceFilePath, tmpFilePath)\r\n      // DEBUG(`File copied: ${sourceFilePath} => ${tmpFilePath}`)\r\n      return tmpFilePath\r\n    } catch (err) {\r\n      console.error(`Error copying file: ${err}`)\r\n      throw err\r\n    }\r\n  }\r\n\r\n  static async clearTempDir() {\r\n    console.log('Clearing /tmp dir ...')\r\n    await CLIHelper.exec('rm', ['-rf', os.tmpdir() + '/*'], 'os.clearTempDir', { cwd: os.tmpdir() })\r\n  }\r\n\r\n  /**\r\n   * Generate a temp filePath in side temp dir (but it is just the file path, no file content existed)\r\n   * @param prefix prepend to the fileName\r\n   * @param fileExtension extension must be with the dot (.), append to the result fileName\r\n   * @returns\r\n   */\r\n  static generateNewTempFilePath(prefix: string = '', fileExtension = '') {\r\n    const tmpFileName = `${prefix}${UtilHelper.createRandom()}${fileExtension}`\r\n    const tmpFilePath = path.join(os.tmpdir(), tmpFileName)\r\n\r\n    return tmpFilePath\r\n  }\r\n\r\n  static async unlinksSafe(paths: string[]) {\r\n    const arr = paths.map(async (p) => {\r\n      if (await FileHelper.checkFileExist(p)) {\r\n        await fsPromises.unlink(p)\r\n      }\r\n    })\r\n\r\n    return Promise.all(arr)\r\n  }\r\n\r\n  /**\r\n   * download remote file into local temp dir\r\n   * @param link\r\n   * @returns local temp file path\r\n   */\r\n  static async cacheRemoteUrl(link: string) {\r\n    if (!link) throw new Error(`${link} is empty, neither URL nor localFile`)\r\n\r\n    if (UtilHelper.isLocalFilePath(link)) {\r\n      return link // already in local, no need to download\r\n    }\r\n\r\n    if (!UtilHelper.isURL(link)) {\r\n      throw new Error(`${link} is neither URL nor localFile`)\r\n    }\r\n\r\n    const url = link\r\n    // https://vbee-studio-tmp.s3.ap-southeast-1.amazonaws.com/voice-cloning/voices/6765858815ba1ce0979a8b35/filename.wav ==> filename.wav\r\n    const fileName = path.basename(link) // = link.split('/').slice(-1)[0]\r\n    const outputFilePath = FileHelper.generateNewTempFilePath('temp-cached_', '_' + fileName)\r\n\r\n    try {\r\n      await RawNetworkHelper.download(url, outputFilePath)\r\n    } catch (err) {\r\n      console.error('Error: 404 not Found: ', url, (err as any).code)\r\n    }\r\n\r\n    return outputFilePath\r\n  }\r\n}\r\n","import path from 'path'\r\nimport { nanoid } from 'nanoid'\r\n\r\n/** noticable log in DEBUG environment */\r\nexport function DEBUG(...args) {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    console.debug('\\x1b[36müêû ------ \\x1b[0m', ...args)\r\n    // [‚ÑπÔ∏è]\r\n  }\r\n}\r\n\r\nexport class UtilHelper {\r\n  static createRandom() {\r\n    return `${new Date().toISOString().substring(0, 10)}_${nanoid()}`\r\n  }\r\n\r\n  /** convert true false to yes/no or icon of yes/no */\r\n  static boolToYesNo(b?: boolean, withText = false) {\r\n    const text = b ? 'yes' : 'no '\r\n    const icon = b ? '‚úÖ' : 'üö´'\r\n\r\n    return icon + (withText ? text : '')\r\n  }\r\n\r\n  /**\r\n   * Checks if a string is a valid URL.\r\n   * @param str The string to check.\r\n   */\r\n  static isURL(str: string): boolean {\r\n    try {\r\n      new URL(str)\r\n      return true\r\n    } catch (error) {\r\n      return false\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if a string is a valid file path. Just file name like \"file\" or \"file.txt\" is false. \"c:/file\" is true\r\n   * @param str The string to check.\r\n   */\r\n  static isLocalFilePath(str: string): boolean {\r\n    if (!str) throw Error('str is empty')\r\n\r\n    // Check if it's an absolute path or relative path\r\n    if (path.isAbsolute(str) || str.startsWith('./') || str.startsWith('../')) {\r\n      return true\r\n    }\r\n    return false\r\n  }\r\n}\r\n","import http from 'http'\r\nimport https from 'https'\r\nimport fs from 'fs'\r\nimport { URL } from 'url'\r\nimport { CustomError } from '../models/CustomError'\r\n\r\nexport interface FileInfo {\r\n  mime: string\r\n  size: number\r\n  filePath: string\r\n}\r\n\r\ninterface DownloadOptions {\r\n  timeout?: number\r\n  headers?: Record<string, string>\r\n}\r\n\r\nexport class DownloadError extends CustomError {\r\n  constructor(message: string, error?: Error | unknown, public readonly statusCode?: number, public readonly url?: string, extra?: any) {\r\n    super(message, error, extra)\r\n    this.name = 'DownloadError'\r\n  }\r\n}\r\n\r\n// TODO: PERFORMANCE test with axios to see what is better/faster\r\n/*\r\n      In Node.js: Axios uses the built-in http and https modules. \r\n      This means that when you use Axios in a Node.js environment, \r\n      it's essentially a wrapper around these core modules, \r\n      providing a higher-level API and additional features.\r\n      */\r\nexport class RawNetworkHelper {\r\n  /**\r\n   * This is stream download using raw http/https API\r\n   * Real-world performance example for a 1GB file:\r\n\r\nStream implementation: ~100MB memory usage\r\nfetch()/axios: ~1.1GB memory usage (entire file + overhead)\r\n\r\nHowever, there are cases where fetch() or axios might be preferred:\r\n\r\nIf you need to process the file in memory anyway\r\nFor very small files where the overhead doesn't matter\r\nWhen you need the additional features these libraries provide (like automatic retries, request interception, etc.)\r\n   */\r\n  static async download(urlString: string, filePath: string, options: DownloadOptions = {}): Promise<FileInfo> {\r\n    // Validate and parse URL\r\n    let url: URL\r\n    try {\r\n      url = new URL(urlString)\r\n    } catch (err) {\r\n      throw new DownloadError(`Invalid URL: ${urlString}`, err, undefined, urlString)\r\n    }\r\n\r\n    // Validate protocol\r\n    if (url.protocol !== 'http:' && url.protocol !== 'https:') {\r\n      throw new DownloadError(`Unsupported protocol: ${url.protocol}`)\r\n    }\r\n\r\n    // Ensure directory exists\r\n    // const directory = path.dirname(filePath)\r\n    // await fs.promises.mkdir(directory, { recursive: true })\r\n\r\n    const { timeout = 30000, headers = {} } = options\r\n\r\n    return new Promise<FileInfo>((resolve, reject) => {\r\n      const fileStream = fs.createWriteStream(filePath)\r\n      let fileInfo: FileInfo = {\r\n        mime: '',\r\n        size: 0,\r\n        filePath\r\n      }\r\n\r\n      const protocol = url.protocol === 'https:' ? https : http\r\n      const request = protocol.get(url, { timeout, headers }, (response) => {\r\n        // // Handle redirects\r\n        // if (response.statusCode === 301 || response.statusCode === 302) {\r\n        //   const redirectUrl = response.headers.location\r\n        //   if (!redirectUrl) {\r\n        //     reject(new DownloadError('Redirect location not provided', response.statusCode, urlString))\r\n        //     return\r\n        //   }\r\n        //   FileDownloader.download(redirectUrl, filePath, options).then(resolve).catch(reject)\r\n        //   return\r\n        // }\r\n\r\n        // Handle error status codes\r\n        if (response.statusCode !== 200) {\r\n          reject(\r\n            new DownloadError(\r\n              `Raw download file error. ${response.statusCode}`,\r\n              //\r\n              undefined,\r\n              response.statusCode,\r\n              urlString\r\n            )\r\n          )\r\n          return\r\n        }\r\n\r\n        // Set file info\r\n        fileInfo = {\r\n          mime: response.headers['content-type'] || '',\r\n          size: parseInt(response.headers['content-length'] || '0', 10),\r\n          filePath\r\n        }\r\n\r\n        response.pipe(fileStream)\r\n      })\r\n\r\n      request.on('error', (err) => {\r\n        fileStream.destroy()\r\n        // TODO: use FileHelper to delete files\r\n        fs.unlink(filePath, () => {\r\n          reject(new DownloadError(`Network error: ${err.message}`, err, undefined, urlString))\r\n        })\r\n      })\r\n      request.on('timeout', () => {\r\n        request.destroy()\r\n        fileStream.destroy()\r\n        fs.unlink(filePath, () => {\r\n          reject(new DownloadError(`Download timed out after ${timeout}ms`, undefined, undefined, urlString))\r\n        })\r\n      })\r\n\r\n      // Handle successful download\r\n      fileStream.on('finish', () => {\r\n        fileStream.close(() => resolve(fileInfo))\r\n      })\r\n      // Handle file system errors\r\n      fileStream.on('error', (err) => {\r\n        fileStream.destroy()\r\n        fs.unlink(filePath, () => {\r\n          reject(new DownloadError(`File system error: ${err.message}`, err, undefined, urlString))\r\n        })\r\n      })\r\n    })\r\n  }\r\n}\r\n","export class CustomError extends Error {\r\n  constructor(\r\n    message: string,\r\n    public readonly error?: Error | unknown,\r\n    public readonly extra?: any\r\n  ) {\r\n    super(message)\r\n    this.name = 'CustomError'\r\n  }\r\n}\r\n"],"names":[],"version":3,"file":"lakdak.umd.js.map","sourceRoot":"../"}