{"mappings":";;;ACAO,SAAS,4CAAQ;IACtB,OAAO;AACT;;ADFA;AEAA,8BAA8B;AAE9B;AAKe;IACb;;;;GAIC,GACD,OAAO,4BAA4B,SAAS,IAAI,EAAU;QACxD,MAAM,oBAAoB,OAAO,MAAM,CAAC,CAAA,GAAA,SAAC,EAAE,iBAAiB,IACzD,MAAM,CAAC,CAAC,GAAG,IAAM;YAChB,IAAI,EAAE,MAAM,CAAC;YACb,OAAO;QACT,GAAG,EAAE,EACJ,MAAM,CAAC,CAAC,UAAE,OAAM,WAAE,QAAO,EAAE,GAAK;YAC/B,OAAO,OAAO,WAAW,GAAG,OAAO,CAAC,WAAW,KAAK,YAAY;QAClE,GACC,GAAG,CAAC,CAAC,WAAE,QAAO,EAAE,GAAK;QACxB,MAAM,oBAAoB,kBAAkB,IAAI,CAAC;QACjD,OAAO;IACT;IAEA;;;;GAIC,GACD,OAAc,qBAAqB,GAAG,EAAE;QACtC,0DAA0D;QAC1D,yEAAyE;QACzE,OAAO,KAAK,QAAQ,iBAAiB,KAAK,OAAO,CAAC,kBAAkB;IACtE;AACF;;;ACrCA,8BAA8B;AAE9B;AAEe;IACb;;;;;GAKC,GACD,OAAO,KAAK,KAAwB,EAAE,YAAY,QAAQ,EAAU;QAClE,IAAI,CAAC,OAAO;QAEZ,OAAO,CAAA,GAAA,aAAK,EAAE,UAAU,CAAC,WAAW,MAAM,CAAC,OAAO,MAAM,CAAC;IAC3D;IAEA;;;;GAIC,GACD,OAAO,mBAAmB,gBAAgB,IAAI,EAA+D;QAC3G,MAAM,aAAE,UAAS,cAAE,WAAU,EAAE,GAAG,CAAA,GAAA,aAAM,AAAD,EAAE,mBAAmB,CAAC,OAAO;2BAClE;YACA,mBAAmB;gBACjB,MAAM;gBACN,QAAQ;YACV;YACA,oBAAoB;gBAClB,MAAM;gBACN,QAAQ;YACV;QACF;QACA,OAAO;uBAAE;wBAAW;QAAW;IACjC;IAEA;;;;;;GAMC,GACD,OAAO,YAAY,SAAS,EAAE,SAAiB,EAAU;QACvD,MAAM,gBAAgB,CAAA,GAAA,aAAM,AAAD,EAAE,aAAa,CACxC;YACE,KAAK;YACL,SAAS,CAAA,GAAA,aAAK,EAAE,SAAS,CAAC,sBAAsB;YAChD,UAAU;QACZ,GACA,OAAO,IAAI,CAAC;QAEd,OAAO,cAAc,QAAQ,CAAC;IAChC;IAEA;;;;;;GAMC,GACD,OAAO,YAAY,UAAU,EAAE,mBAA2B,EAAU;QAClE,MAAM,gBAAgB,CAAA,GAAA,aAAM,AAAD,EAAE,cAAc,CACzC;YACE,KAAK;YACL,uDAAuD;YACvD,2DAA2D;YAC3D,wCAAwC;YACxC,SAAS,CAAA,GAAA,aAAK,EAAE,SAAS,CAAC,sBAAsB;YAChD,UAAU;QACZ,GACA,OAAO,IAAI,CAAC,qBAAqB;QAEnC,OAAO,cAAc,QAAQ,CAAC;IAChC;AACF;;;AC7EA,sCAAsC,GACtC,AAAe;IACb;;;;GAIC,GACD,OAAc,mBAAmB,GAAG,EAAE;QACpC,MAAM,OAAO,KAAK,SAAS,eAAe,QAAQ,WAAW;QAE7D,OAAO;IACT;AACF;","sources":["src/index.ts","src/libs/lib.ts","src/libs/DevOpsHelper.ts","src/libs/SecurityHelper.ts","src/libs/HttpProtocolHelper.ts"],"sourcesContent":["export { hello as testFunction } from './libs/lib'\n\nimport DevOpsHelper from './libs/DevOpsHelper'\nimport SecurityHelper from './libs/SecurityHelper'\nimport HttpProtocolHelper from './libs/HttpProtocolHelper'\nexport { DevOpsHelper, SecurityHelper, HttpProtocolHelper }\n","export function hello() {\r\n  return 1;\r\n}\r\n","/// <reference types=\"node\" />\n\nimport os from 'os'\n\n/**\n * Helper to  inspect, check, analyse command send to chatbot\n */\nexport default class DevOpsHelper {\n  /**\n   * Get current server IP address\n   * @param ipType \"v4\" or \"v6\"\n   * @returns\n   */\n  static getCurrentServerIpAddresses(ipType = 'v4'): string {\n    const networkInterfaces = Object.values(os.networkInterfaces())\n      .reduce((r, a) => {\n        r = r.concat(a)\n        return r\n      }, [])\n      .filter(({ family, address }) => {\n        return family.toLowerCase().indexOf(ipType) >= 0 && address !== '127.0.0.1'\n      })\n      .map(({ address }) => address)\n    const serverIpAddresses = networkInterfaces.join(', ')\n    return serverIpAddresses\n  }\n\n  /**\n   * Get IP from request (if behind proxy, use X-Forwarded-For header)\n   * @param req\n   * @returns\n   */\n  public static extractIpFromRequest(req) {\n    // TODO: should improve this func to whitelist the proxies\n    // TODO: should use this library https://www.npmjs.com/package/request-ip\n    return req?.socket?.remoteAddress || req?.headers['x-forwarded-for']\n  }\n}\n","/// <reference types=\"node\" />\n\nimport crypto from 'crypto'\n\nexport default class SecurityHelper {\n  /**\n   *\n   * @param input\n   * @param algorithm  \"sha1\" \"sha256\"\n   * @returns hex string\n   */\n  static hash(input: crypto.BinaryLike, algorithm = 'sha256'): string {\n    if (!input) return\n\n    return crypto.createHash(algorithm).update(input).digest('hex')\n  }\n\n  /**\n   *\n   * @param modulusLength effective key size 2048 bit (good until 2030), after 2030, use 3072 bit\n   * @returns keypair: object of public and private\n   */\n  static generateRSAKeyPair(modulusLength = 2048): { publicKey: string | Buffer; privateKey: string | Buffer } {\n    const { publicKey, privateKey } = crypto.generateKeyPairSync('rsa', {\n      modulusLength,\n      publicKeyEncoding: {\n        type: 'spki',\n        format: 'pem'\n      },\n      privateKeyEncoding: {\n        type: 'pkcs8',\n        format: 'pem'\n      }\n    })\n    return { publicKey, privateKey }\n  }\n\n  /**\n   * Encrypt using publicKey, the encrypted data is in the form of bytes, so we print it in base64 format\n   * so that it's displayed in a more readable form\n   * @param publicKey\n   * @param plainText\n   * @returns String base64 format\n   */\n  static encryptText(publicKey, plainText: string): string {\n    const encryptedData = crypto.publicEncrypt(\n      {\n        key: publicKey,\n        padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,\n        oaepHash: 'sha256'\n      },\n      Buffer.from(plainText)\n    )\n    return encryptedData.toString('base64')\n  }\n\n  /**\n   * decrypt using privateKey. The decrypted data is of the Buffer type,\n   * which we can convert to a string to reveal the original data\n   * @param privateKey\n   * @param encryptedTextBase64 String in base64 format\n   * @returns utf-8 string\n   */\n  static decryptText(privateKey, encryptedTextBase64: string): string {\n    const decryptedData = crypto.privateDecrypt(\n      {\n        key: privateKey,\n        // In order to decrypt the data, we need to specify the\n        // same hashing function and padding scheme that we used to\n        // encrypt the data in the previous step\n        padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,\n        oaepHash: 'sha256'\n      },\n      Buffer.from(encryptedTextBase64, 'base64')\n    )\n    return decryptedData.toString('utf8')\n  }\n}\n","/** Helper to work with HTTP Protocol */\nexport default class HttpProtocolHelper {\n  /**\n   * extract bearer token from request header\n   * @param req\n   * @returns\n   */\n  public static extractBearerToken(req) {\n    const hash = req?.headers?.authorization?.replace(\"Bearer \", \"\")\n\n    return hash\n  }\n}\n"],"names":[],"version":3,"file":"lakdak.es.js.map","sourceRoot":"../"}